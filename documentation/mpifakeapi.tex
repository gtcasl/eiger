% author: Ben Allan
% inst: sandia national laboratories
% date: Dec 2012
\section{Parallel Non-SQL Application Programming Interface}
\label{sec:mpifakeapi}
This document defines the MPI non-SQL API, for convenience named {\em mpifakeeiger}.

\subsection{Requirements}

\begin{itemize}
\item Provide as close to the SQL-based Eiger API as possible without using SQL where mysql is unavailable.

\item Permit multiple executions and process ranks to be accumulated into the same data set.

\item Provide a mechanism to load the non-sql results into mysql.
 
\item Generate obvious errors (preferably at compile time) where incompatibilities exist.

\end{itemize}

\subsection{Differences with serial fake Eiger}

\subsubsection {Runtime behavior} 
Libmpifakeeiger replaces libfakeeiger and writes to a fixed file set "{\em mpifakeeiger.*.log}" where * is the process rank in the mpi job. The assumptions needed to properly apply mpifakeeiger are less restrictive than the assumptions for fakeeiger. Instead of requiring metadata commits always happen in the same sequence, mpifakeeiger allows any sequence but places a restriction on the naming of eiger::Dataset objects. Mpifakeeiger.log is written as eiger object commits occur and contains the data needed to read a collected result set into a mysql database using the mfeloader utility. There is no offsets file needed as in the simpler fakeeiger case, as the process of merging the data into a single database automatically handles output from additional runs.
 Log files generated by multiple ranks in an MPI parallel job are {\em independent} and will contain Dataset identifier conflicts. The mfeloader application handles resolving these conflicts if (and only if) Dataset names map equivalently to experimental parameters on different MPI ranks.

Because of the in-process nature of mpifakeeiger, it is not inherently thread-safe. Eiger calls still should typically be made only from the lead OMP thread within an MPI rank when profiling OpenMp hybrid applications with mpifakeeiger.


\subsubsection{Identifiers} Using MySQL permits nearly arbitrary combining of performance experiments into a single database. Part of this functionality involves providing unique integer identifiers for metadata items. In some cases, creating the same kind of item by the same name results in a database query to check if the metadata combination pre-exists; if the item exists, the integer ID is read from the database rather than generated. Obviously, this cannot be done efficiently without MySQL (or even with MySQL on very slow parallel file systems). 

The mpifakeeiger solution is to recognize that a restricted, but still useful, pattern of Eiger use is for an MPI application (across runs or ranks) to declare all Dataset objects with names that encode the experimental parameters, resulting in the same integer identifiers. This encoding can be consistently and almost effortlessly applied with machine-based techniques \cite{lwperf} beyond the scope of this section. For completeness, a hand-crafted example follows:
\begin{verbatim}
  eiger::ApplicationID aid = ...;
  ...
  // build the dataset name based on the upper bounds array
  std::ostringstream dsbuf;
  dsbuf << "force_loopnest_3d";
  for (int i=0;i<3;i++) {
    dsbuf << "_" << upper[e];
  }
  std::string dsname = dsbuf.str();
  eiger::Dataset ds(aid, dsname, "noDesc", "noURL");
  ds.commit();
\end{verbatim}



\subsubsection{Compilation} As the Eiger API is based on concrete classes rather than a functional interface, mpifakeeiger reimplements those classes in an alternate header. Include statements must be changed from eiger.h to mpifakeeiger.h. As the use of eiger itself is likely to be conditional, we provide an example of controlling both the use and flavor of eiger by adding -D options to the compiler invocation.

\begin{verbatim} 
%# compile line

% g++ -D_USE_EIGER -D_USE_FAKEEIGER $OTHERFLAGS app.cxx

%# include block from app.cxx

  #ifdef _USE_EIGER
  #ifdef _USE_FAKEEIGER
  #include "mpifakeeiger.h"
  #else
  #include "eiger.h"
  #endif
  #endif
\end{verbatim}

In this example, OTHERFLAGS must contain the options needed to find the mpifakeeiger library.

Construction of libmpifakeeiger is not presently handled by the eiger SConstruct file. A
GNUmakefile is provided, which will need minor modifications in the variables defining the
flags for MySQL and MPI dependencies.

\subsubsection{Linking} As the Eiger API is based on concrete classes rather than a functional interface, fakeeiger provides an alternate library, {\em libmpifakeeiger}, which implements all the data writing functions of libeiger. Lacking mysql support, libmpifakeeiger provides none of the data reading functionality of libeiger, except where it is faked as described under Runtime behavior. In particular, the object constructors which read an object by its integer Id from the database are not available; this should produce obvious errors at compile and link times. These functions are clearly marked with macro NEEDSQLREAD in mpifakeeiger.h.

\subsubsection{Output} The output always goes to mpifakeeiger.*.log, which normally will be in the directory from which the eigerized program is executed. The output may be edited at the top to adjust the name of the database or other parameters before loading into the database if needed. Loading from mpifakeeiger.*.log is done by running mfeloader while in the directory where mpifakeeiger.*.log resides.

\subsubsection{Output Format} To address scalability and file size issues, the mpifakeeiger log format (while remaining ASCII for data readability) reduces the keywords to single characters, as documented in fakekeywords.h. This reduction is optional: building the mpifakeeiger library with -DFAKE\_KEYS\_FULL will enable the long keywords for debugging.


\subsection{Possible improvements}

\begin{itemize}
\item[Filename] mpifakeeiger.*.log is hardcoded. This could be changed but has not thusfar proved necessary for practical work.
\item[Format] Fakeeiger uses a human-readable, line-oriented format. A potential speed improvement (at the expense of debugging ease) would be to convert to a binary file format in the log. This would not necessarily lead to smaller output files.
\item[Build] The mpifakeeiger header arrangements could be shifted and the libraries unified so that application code requires no changes except the addition of -D\_USE\_FAKEEIGER to the compilation. This would require defining eiger in terms of a macro or namespace trick.
\item[Thread safety] The mpifakeeiger api is not intentionally thread-safe. To date, it has only been used to collect data from single processes and MPI processes where ranks are single-threaded. 
\end{itemize}
