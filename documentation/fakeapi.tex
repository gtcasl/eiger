% author: Ben Allan
% inst: sandia national laboratories
% date: Oct 2012
\section{Non-SQL Application Programming Interface}
\label{sec:fakeapi}
This document defines the Non-SQL API to Eiger, for convenience named {\em fakeeiger}.

\subsection{Requirements}

\begin{itemize}
\item Provide as close to the SQL-based Eiger API as possible without using SQL where mysql is unavailable.

\item Permit multiple executions to be accumulated into the same data set.

\item Provide a mechanism to load the non-sql results into mysql.
 
\item Generate obvious errors (preferably at compile time) where incompatibilities exist.

\end{itemize}

\subsection{Differences with MySQL-based Eiger}

\subsubsection {Runtime behavior} 
Libfakeeiger replaces interprocess communication (and possible database file reads)  with a lightweight in-process approximation of the database behavior and filesystem writes to a pair of fixed files "{\em fakeeiger.log}" and "{\em fakeeiger.offsets}". Fakeeiger.log is written as eiger object commits occur and contains the data needed to read a collected result set into a mysql database using the \texttt{eiger-loader} utility, which takes a list of files to parse as command line arguments. Fakeeiger.offsets is written at the end of the run and contains the integer id of the next execution and trial; these ids are needed if multiple runs are to be appended to the same fakeeiger.log. Clearing the offsets (and existing data) is done by removing or renaming the fakeeiger.* files. If fakeeiger.offsets is not present, fakeeiger.log is overwritten. 

Because of the node-local, in-process nature of fakeeiger, it is not inherently thread-safe. Eiger calls should typically be made only from the lead thread when profiling OpenMp applications with fakeeiger. Fakeeiger log files generated by multiple processes in an MPI parallel job are {\em independent} and will contain identifier conflicts. Useful analysis of compute-bound code sections can still occur under these conditions.

\subsubsection{Identifiers} Using MySQL permits nearly arbitrary combining of performance experiments into a single database. Part of this functionality involves providing unique integer identifiers for metadata items. In some cases, creating the same kind of item by the same name results in a database query to check if the metadata combination pre-exists; if the item exists, the integer ID is read from the database rather than generated. Obviously, this cannot be done efficiently without MySQL (or even with MySQL on very slow parallel file systems). The fakeeiger solution is to recognize that a restricted, but still useful, pattern of Eiger use is for a given application (across distinct runs) to declare all the metadata in the same order every time, resulting in the same integer identifiers. Within a run, where metadata definitions are repeated, a map is used to ensure appropriate common identifiers are used. Where identifiers must be distinct across all runs, offsets are stored at the end of a run and read at the beginning as previously noted. 

\subsubsection{Compilation} As the Eiger API is based on concrete classes rather than a functional interface, fakeeiger reimplements those classes in an alternate header. Include statements must be changed from eiger.h to fakeeiger.h. As the use of eiger itself is likely to be conditional, we provide an example of controlling both the use and flavor of eiger by adding -D options to the compiler invocation.

\begin{verbatim} 
%# compile line

% g++ -D_USE_EIGER -D_USE_FAKEEIGER $OTHERFLAGS app.cxx

%# include block from app.cxx

  #ifdef _USE_EIGER
  #ifdef _USE_FAKEEIGER
  #include "fakeeiger.h"
  #else
  #include "eiger.h"
  #endif
  #endif

\end{verbatim}

\subsubsection{Linking} As the Eiger API is based on concrete classes rather than a functional interface, fakeeiger provides an alternate library, {\em libfakeeiger}, which implements all the data writing functions of libeiger. Lacking mysql support, libfakeeiger provides none of the data reading functionality of libeiger, except where it is faked as described under Runtime behavior. In particular, the object constructors which read an object by its integer Id from the database are not available; this should produce obvious errors at compile and link times. These functions are clearly marked with macro NEEDSQLREAD in fakeeiger.h.

\subsubsection{Output} The output always goes to fakeeiger.log, which normally will be in the directory from which the eigerized program is executed. The output may be edited at the top to adjust the name of the database or other parameters before loading into the database if needed. Loading from fakeeiger.log is done by running \texttt{eiger-loader}.



\subsection{Possible improvements}

\begin{itemize}
\item[Filename] fakeeiger.log is hardcoded. This could be changed but has not thusfar proved necessary for practical work.
\item[Format] Fakeeiger uses a human-readable, line-oriented format. A speed improvement (at the expense of debugging ease) would be to convert to a binary file format in fakeeiger.log.
\item[Build] The fakeeiger header arrangements could be shifted and the libraries unified so that application code requires no changes except the addition of -D\_USE\_FAKEEIGER to the compilation. This would require defining eiger in terms of a macro or namespace trick.
\item[Thread safety] The fakeeiger api is not intentionally thread-safe. To date, it has only been used to collect data from single processes or from multiple threads/processes where a leader handles performance data logging. A simple improvement would be to open one log-file per process, perhaps by suffixing the process id to fakeeiger.log. To support multithread or multi-process use, a revised FakeEigerLoader class will be needed to coordinate merging of various IDs. Alternately, analysis could be done rankwise and fakeeiger would need to be slightly revised to incorporate process rank into the log filename.
\end{itemize}
