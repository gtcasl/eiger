#ifndef perf_h
#define perf_h
#include <map>
#include <cassert>
#ifdef _USE_EIGER_MODEL
#include <sstmac/software/api/eiger/sstmac_compute_eiger.h>
#endif

#include "eigerbackend.h"
#include "csvbackend.h"
#include "nullbackend.h"
#include "formatter.h"

#ifdef _USE_CSV
#define PERFBACKEND CSVBackend
#endif

#if defined(_USE_EIGER) || defined(_USE_FAKEEIGER)
#define PERFBACKEND EigerBackend
#endif

#ifdef _USE_EIGER_MODEL
#define PERFBACKEND NullBackend
#endif

// An enum that must be tailored (along with getlog) to the code being instrumented.
// We want to define a single pile of instrumentation that
// gets installed in many different source variants of a code where the stuff here is common.
// Also want it to be autogenerated and to be fast to dispatch during runs, so no string 
// compares.
enum Location {
	X, // dummy for example
#include "LocationElements.h"
};


/** singleton class so that Eiger logging does not pollute argument list and headers.
 It needs to assume something in order to be about measuring node-level
 performance benchmarking, so it assumes that mpi_comm_world spans only the
 node.

The specific perf counters and timers collected implicitly are tailored
in csvformatter.h and .cpp start/stop functions and in 
DEFAULT_PERFCTRS definition.
*/
class Perf {
public: /** USER interface; wrap these calls in PERFDECL to allow Perf suppression
        at build time by passing -DPERF_DISABLE to compilers
        init, mpiArgs, finalize may only be called in order, though
        spread across the application.
         */

	/** Several string option inputs; none can include no whitespace.
        * @param host: can be a name or an architecture.
	* @param tools: compiler set.
	* @param application: name of the application
	* @param database: name of database in mysql.
        * @param prefix: used for the data file set.
        * @param suffix: typically .log (.dat, .out, .txt, etc) for data file set
	* @bug no way to specify eiger database user, pw, hostname; hard coded.
        */
	static void init(std::string machine, 
                   std::string application, 
                   std::string database, 
                   std::string prefix, std::string suffix);
	static void mpiArgs(int rank, int size) ;
	static void finalize();
	// The rest of the perf user interface is the
  // PERFDECL, PERFLOG, PERFSTOP, and optional PERFSTART at bottom.

  static std::map<std::string, double>& getInvariants(){
    static std::map<std::string, double> invariants;
    return invariants;
  }
private:
	std::map<enum Location, formatter<PERFBACKEND> *> log;
	std::string machine;
	std::string app;
	std::string prefix;
	std::string suffix;
	bool append;
	int mpirank;
	int mpisize;
	bool mpiused;


	void initX(formatter<PERFBACKEND> *cf) {}
#include "InitFuncs.h"

	Perf(std::string machine, std::string app, std::string prefix, 
       std::string suffix, bool append) 
    : machine(machine), app(app), prefix(prefix), suffix(suffix), 
      append(append), mpirank(0), mpisize(1), mpiused(false) {
	}
	~Perf();

	formatter<PERFBACKEND> *getLog(enum Location l, std::string filename);

public:
	// macro user only
	static formatter<PERFBACKEND> *Log(enum Location l, std::string sitename);
};

// which logger class are we using
#define PERF Perf

// what is its internal logger class
#define PERFFORMATTER formatter<PERFBACKEND>

// Initialize the logging
#define PERFINIT(m,a,d,p,s) PERF::init(m,a,d,p,s);

// Finalize the logging
#define PERFFINALIZE PERF::finalize();

// Set MPI args
#define PERFMPIARGS(r,s) PERF::mpiArgs(r,s);

#ifdef _USE_EIGER_MODEL
#define MODELCALL(X,...) \
  {std::map<std::string, double> eigerparams; \
  std::string sitename = #X; \
  for(std::map<std::string,double>::const_iterator it = PERF::getInvariants().begin(); \
      it != PERF::getInvariants().end(); ++it){ \
    eigerparams[sitename + "_" + it->first] = it->second; \
  } \
  __VA_ARGS__; \
  SSTMAC_compute_eiger(eigerparams, #X ".model"); }
#define STARTREMOVECODE \
  if(0){
#define STOPREMOVECODE }
#define DR(v) eigerparams[sitename + "_" #v] = v
#define DD(v) eigerparams[sitename + "_" #v] = v
#define DN(v) eigerparams[sitename + "_" #v] = v
#define IR(v) eigerparams[sitename + "_" #v] = v
#define ID(v) eigerparams[sitename + "_" #v] = v
#define IN(v) eigerparams[sitename + "_" #v] = v

#define PERFSTOPKEEP(X, ...)
#else // no model
#define MODELCALL(X,...)
#define STARTREMOVECODE
#define STOPREMOVECODE
// D* & I* macros are used at PERFSTOP to store values.
// Their appearance in PERFLOG (which must match PERFSTOP)
// is preprocessed by means other than C preprocessor into initialization calls as needed.
// Typically, application code uses only IP to name integer inputs
#define DR(v) tmpcf->put(v)
#define DD(v) tmpcf->put(v)
#define DN(v) tmpcf->put(v)
#define IR(v) tmpcf->put(v)
#define ID(v) tmpcf->put(v)
#define IN(v) tmpcf->put(v)

#define PERFSTOPKEEP(X, ...) \
   { log##X->stop();  formatter<PERFBACKEND> *tmpcf = log##X;  __VA_ARGS__ ; } log##X->nextrow()

#endif // _USE_EIGER_MODEL

/** Wraps statements that should be suppressed if PERF_DISABLE is defined.
// The other PERF macros are automatically suppressed if PERF_DISABLE is defined.
*/
#define PERFDECL(...) __VA_ARGS__
/** This macro is able to handle overlapping timers by different names. 
 It defines a local variable logX. X is a Location enum member, a timer name.
 The variable are used only by the include file generator,
 E.g. PERFLOG(site1,IP(param1))
 @param X name of timer location; must be unique in application and follow
the rules of C enum members.
@param ... I*(name) or D*(name) for int/double log data names .
*/
#define PERFLOG(X, ...) \
  PERFLOGKEEP(X,__VA_ARGS__); \
  STARTREMOVECODE

#define PERFLOGKEEP(X,...) \
  formatter<PERFBACKEND> * log##X = Perf::Log(lwperf_##X, #X); log##X->start(); \
  MODELCALL(X,__VA_ARGS__)

/** Compute perf counters and record values. USER values should already be computed.
 VARARGS list should be same as to PERFLOG, e.g. PERFSTOP(site1,IP(param1_value),...)
but here the values are given to I*()/D*() rather than their names.
*/
#define PERFSTOP(X, ...) \
    STOPREMOVECODE \
    PERFSTOPKEEP(X, __VA_ARGS__)


// reset reference time point and other perf counter initial values
// not normally needed separately before PERFLOG, but C++ scoping rules
// may make it handy to have in more complex cases.
#define PERFSTART(X) \
  log##X->start()

// Register a new invariant metric. This value, once set, does not change
// throughout the execution of the application. These are your determinisitic 
// metrics; use these to describe any input dataset-specific information 
// about your application.
#define REGISTERINVARIANT(name, value) \
  PERF::getInvariants()[#name] = (double) (value);

#endif // perf_h
