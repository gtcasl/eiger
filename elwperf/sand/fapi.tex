\chapter{FORTRAN application support}
\label{sec:fortran}
The fortran binding is, as lwperf in general, functional, preliminary, and intended for tailoring by the user.  A preprocessor must be included in the compile step, either by passing a compiler option to force it or by using a suffix the compiler recognizes as needing preprocessing. The preprocessor does not need to be a separate C preprocessor; the builtin gfortran preprocessor is known to work.

\section{FORTRAN api}
\label{sec:fapi}
The prefix lwperf\_ is used for all lwperf symbols in fortran, to avoid conflicts with user code. The header to be included is {\em lwperf\_f.h}.
The application code changes are similar to those for C/C++, inserting macros where needed, e.g.:
\begin{verbatim}
   module test1
     integer :: n
     contains
     recursive subroutine sub1(x)
     integer,intent(inout):: x
       if (x < n) then
         x = x + 1
         print *, 'x = ', x
         call sub1(x)
       end if
     end subroutine sub1
   end module test1

#include "lwperf_f.h"

  program main
    use test1
    PERF_USE

    integer :: x = 0
    integer :: nx = 0
    integer :: ierr,rank = 0, sz
    PERFDECL(real(kind=lwperf_double) :: dp =0 ) !! 8-byte C double if using lwperf

    call MPI_INIT(ierr)
    call MPI_Comm_rank(MPI_COMM_WORLD,rank,ierr)
    call MPI_Comm_size(MPI_COMM_WORLD,sz,ierr)
    PERF_INIT
    PERF_MPI(rank,sz)
    PERF_OPTS("x5550","gfortran","app.F90","fortapp","tesla.",".log") 

    if (rank == 0) then
      print *, 'Enter number of repeats'
      read (*,*) n
    end if
    call MPI_Bcast(n,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr);

    PERFLOG1(sub_1,IP(n)) 
    PERFLOG2(sub_2,IP(nx),DP(dp))
    call sub1(x)
    PERFSTOP2(sub_2,IP(nx),DP(dp))
    PERFSTOP1(sub_1,IP(n))
    PERF_FINAL
    call MPI_FINALIZE()
  end program main
\end{verbatim}

Note that Fortran preprocessors do not support variable-length macros as in C99. Thus, we must use macro names that include the number of measurements. Also, the PERFDECL macro in Fortran will not
accomodate statements containing commas.

\section{FORTRAN build}
\label{sec:fbuild}
As with C++, some simple portions of the Fortran binding must be generated based on a scan of the sites defined in the application code. This scan is performed and the generated code is updated by the simple utility {\em updateLoggersF90.sh} and supporting scripts {\em ./gencsave.body.sh}, {\em ./gencsave.sh}, and {\em ./genfsave.sh}. These scripts may be tailored to the user's application source code, in most cases by adjusting the definition of the {\em ffiles} variable at the top of {\em updateLoggersF90.sh}.

The logger can be kept in sync with the user code with a simple makefile rule such as:
\begin{verbatim}
flocations.h: $(FSRC) updateLoggersF90.sh
        ./updateLoggersF90.sh
\end{verbatim}

Compiling and linking mixed language code is often tricky. Here is an example that may be inspirational; further explanation is beyond the scope of this note. Several additional examples are included in the Make.f90* build scripts.

\begin{verbatim}
mpif90.openmpi  fperf.o app.F90 -D_USE_EIGER \
cperf.o eperf.o eigerformatter.o csvformatter.o diffrusage.o \
/home/baallan/sst/gatech/eiger-svn/api/gcc/libeigerInterface.a \
/usr/lib/libmysqlpp.a -lmysqlclient \
-lmpi_cxx -lstdc++ \
-o ../app_u11f90
\end{verbatim}

A full FORTRAN MPI application (gtc) has been instrumented with lwperf, where the lwperf support code is treated as a library (generated at application build time). This approach has the least impact on the fortran build process and directory structure; contact Ben Allan or Gilbert Hendry for access to this example.


