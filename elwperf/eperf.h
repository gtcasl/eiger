#ifndef eperf_h
#define eperf_h
#include "eigerformatter.h"
#include <map>
#include <cassert>

// An enum that must be tailored (along with getlog) to the code being instrumented.
// We want to define a single pile of instrumentation that
// gets installed in many different source variants of a code where the stuff here is common.
// Also want it to be autogenerated and to be fast to dispatch during runs, so no string 
// compares.
enum Location {
	X, // dummy for example
#ifndef PERF_DISABLE
#include "LocationElements.h"
#endif
};


/** singleton class so that Eiger logging does not pollute argument list and headers.
 It needs to assume something in order to be about measuring node-level
 performance benchmarking, so it assumes that mpi_comm_world spans only the
 node.

The specific perf counters and timers collected implicitly are tailored
in csvformatter.h and .cpp start/stop functions and in 
DEFAULT_PERFCTRS definition.
*/
class EigerPerf {
public: /** USER interface; wrap these calls in PERFDECL to allow Perf suppression
        at build time by passing -DPERF_DISABLE to compilers
        init, file[or string]Options, mpiArgs, finalize may only be called in order, though
        spread across the application.
         */

	static void init();
	static void mpiArgs(int rank, int size) ;
	/** 
	* deprecated options.
        * @param prefix: typically a host or architecture name for the data file set.
        * @param suffix: typically .log (.dat, .out, .txt, etc) for data file set
        */
	static void fileOptions(std::string prefix, std::string suffix);
	/** Several string option inputs; none can include no whitespace.
        * @param host: can be a name or an architecture.
	* @param tools: compiler set.
	* @param application: name of the application
	* @param database: name of database in mysql.
        * @param prefix: used for the data file set.
        * @param suffix: typically .log (.dat, .out, .txt, etc) for data file set
	* @bug no way to specify eiger database user, pw, hostname; hard coded.
        */
	static void stringOptions(std::string host, std::string tools, std::string application, std::string database, std::string prefix, std::string suffix);
	static void finalize();
	// The rest of the perf user interface is the
        // PERFDECL, PERFLOG, PERFSTOP, and optional PERFSTART at bottom.

private:
	eigercontext *epec; // valid after fileOptions
	std::map<enum Location, eigerformatter *> log;
	std::string prefix;
	std::string suffix;
	bool append;
	int mpirank;
	int mpisize;
	bool mpiused;

	void initX(eigerformatter *cf) {}
#ifndef PERF_DISABLE
#include "EigerInitFuncs.h"
#endif

	EigerPerf(bool append) : append(append), mpirank(0), mpisize(1), mpiused(false) {
	}
	~EigerPerf() {
		for (std::map<enum Location, eigerformatter *>::iterator i = log.begin(); i != log.end(); i++) {
			delete i->second;
		}
		delete epec; epec = 0;
	}

	std::string makeFileName(std::string & filename);

	eigerformatter *getLog(enum Location l, std::string filename, bool screen) {
		assert(epec != 0 || 0 == "PERFLOG called before PERFOPTS");
		eigerformatter *cf = log[l];
		if (!cf) {
			std::string sname = filename; 
#ifdef _EIGER_NOCSV
			std::string csvname = "";
#else
			std::string csvname = makeFileName(filename);
#endif
			eigerformatter * ncf = new eigerformatter(csvname,screen, mpirank, mpisize, append, sname, epec);
			switch (l) {
			case X: initX(ncf); break;
#ifndef PERF_DISABLE
#include "InitSwitchElements.h"
#endif
			default:
				assert(0 == "unexpected Location given to PERFLOG");
				break;
			}
			if (!append) { ncf->writeheaders(); }
			log[l] = ncf;
		} else {
			return cf;
		}
		cf = log[l];
		return cf;
	}

public:
	// macro user only
	static eigerformatter *Log(enum Location l, std::string sitename, bool screen);
};

#ifdef PERF_DISABLE
// turn it all off
#define PERF ErRoR
#define PERFDECL(...)
#define PERFLOG(X, Y, ...)
#define PERFSTART(X)
#define PERFSTOP(X, ...) 
#define DP(v)
#define IP(v)

#else // no PERF_DISABLE defined

// which logger class are we using
#define PERF EigerPerf

// what is its internal logger class
#define PERFFORMATTER eigerformatter

#ifdef _LWPERF_SCREEN
#define _USE_LS true
#else
#define _USE_LS false
#endif


/** Wraps statements that should be suppressed if PERF_DISABLE is defined.
// The other PERF macros are automatically suppressed if PERF_DISABLE is defined.
*/
#define PERFDECL(...) __VA_ARGS__
/** This macro is able to handle overlapping timers by different names. 
 It defines a local variable logX. X is a Location enum member, a timer name.
 The variable are used only by the include file generator,
 E.g. PERFLOG(site1,IP(param1))
 @param X name of timer location; must be unique in application and follow
the rules of C enum members.
@param ... IP(name) or DP(name) for int/double log data names .
*/
#define PERFLOG(X, Y, ...) \
  eigerformatter * log##X = EigerPerf::Log(lwperf_##X, #X, _USE_LS); log##X->start()

/** Compute perf counters and record values. USER values should already be computed.
 VARARGS list should be same as to PERFLOG, e.g. PERFSTOP(site1,IP(param1_value),...)
but here the values are given to IP()/DP() rather than their names.
*/
#define PERFSTOP(X, ...) \
   { log##X->stop();  eigerformatter *tmpcf = log##X;  __VA_ARGS__ ; } log##X->nextrow()

// reset reference time point and other perf counter initial values
// not normally needed separately before PERFLOG, but C++ scoping rules
// may make it handy to have in more complex cases.
#define PERFSTART(X) \
  log##X->start()

// DP & IP macros are used at PERFSTOP to store values.
// Their appearance in PERFLOG (which must match PERFSTOP)
// is preprocessed by means other than C preprocessor into initialization calls as needed.
// Typically, application code uses only IP to name integer inputs

// double precision number (measured time for example) not caught by default perf counters
#define DP(v) tmpcf->put(v)
// integer parameters, assumed to be deterministic in eiger terminology
#define IP(v) tmpcf->put(v)

#endif // PERF_DISABLE

#endif // eperf_h
